#!/usr/bin/env python3
"""
Decode keystroke pairs generated by USB Rubber Ducky payloads.

The original script only handled a US keyboard layout; this version lets you
choose between QWERTY and AZERTY so the recovered text matches the implant's
language. Usage:

    ./DuckDecoder.py decode dump.bin --layout azerty
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path

SHIFT_MASK = 0x22  # Left (0x02) or right (0x20) shift bits in the modifier byte.
IGNORED_KEYCODES = {0x00, 0x01, 0xFF}
BACKSPACE_CODE = 0x2A
TAB_CODE = 0x2B
ENTER_CODE = 0x28
DELETE_CODE = 0x4C

SPECIAL_TOKENS = {
    0x52: "<UP>",
    0x51: "<DOWN>",
    0x4F: "<RIGHT>",
    0x50: "<LEFT>",
    0x4C: "<DEL>",
}


@dataclass(frozen=True)
class KeyMapping:
    normal: str
    shifted: str | None = None

    def resolve(self, shift_pressed: bool) -> str:
        if shift_pressed and self.shifted:
            return self.shifted
        return self.normal


def _km(normal: str, shifted: str | None = None) -> KeyMapping:
    return KeyMapping(normal, shifted or None)


def _build_qwerty_layout() -> dict[int, KeyMapping]:
    return {
        0x04: _km("a", "A"),
        0x05: _km("b", "B"),
        0x06: _km("c", "C"),
        0x07: _km("d", "D"),
        0x08: _km("e", "E"),
        0x09: _km("f", "F"),
        0x0A: _km("g", "G"),
        0x0B: _km("h", "H"),
        0x0C: _km("i", "I"),
        0x0D: _km("j", "J"),
        0x0E: _km("k", "K"),
        0x0F: _km("l", "L"),
        0x10: _km("m", "M"),
        0x11: _km("n", "N"),
        0x12: _km("o", "O"),
        0x13: _km("p", "P"),
        0x14: _km("q", "Q"),
        0x15: _km("r", "R"),
        0x16: _km("s", "S"),
        0x17: _km("t", "T"),
        0x18: _km("u", "U"),
        0x19: _km("v", "V"),
        0x1A: _km("w", "W"),
        0x1B: _km("x", "X"),
        0x1C: _km("y", "Y"),
        0x1D: _km("z", "Z"),
        0x1E: _km("1", "!"),
        0x1F: _km("2", "@"),
        0x20: _km("3", "#"),
        0x21: _km("4", "$"),
        0x22: _km("5", "%"),
        0x23: _km("6", "^"),
        0x24: _km("7", "&"),
        0x25: _km("8", "*"),
        0x26: _km("9", "("),
        0x27: _km("0", ")"),
        0x2D: _km("-", "_"),
        0x2E: _km("=", "+"),
        0x2F: _km("[", "{"),
        0x30: _km("]", "}"),
        0x31: _km("\\", "|"),
        0x33: _km(";", ":"),
        0x34: _km("'", '"'),
        0x35: _km("`", "~"),
        0x36: _km(",", "<"),
        0x37: _km(".", ">"),
        0x38: _km("/", "?"),
        0x2B: _km("\t"),
        0x28: _km("\n"),
        0x2C: _km(" "),
    }


def _build_azerty_layout() -> dict[int, KeyMapping]:
    return {
        0x04: _km("q", "Q"),
        0x05: _km("b", "B"),
        0x06: _km("c", "C"),
        0x07: _km("d", "D"),
        0x08: _km("e", "E"),
        0x09: _km("f", "F"),
        0x0A: _km("g", "G"),
        0x0B: _km("h", "H"),
        0x0C: _km("i", "I"),
        0x0D: _km("j", "J"),
        0x0E: _km("k", "K"),
        0x0F: _km("l", "L"),
        0x10: _km(",", "?"),
        0x11: _km("n", "N"),
        0x12: _km("o", "O"),
        0x13: _km("p", "P"),
        0x14: _km("a", "A"),
        0x15: _km("r", "R"),
        0x16: _km("s", "S"),
        0x17: _km("t", "T"),
        0x18: _km("u", "U"),
        0x19: _km("v", "V"),
        0x1A: _km("z", "Z"),
        0x1B: _km("x", "X"),
        0x1C: _km("y", "Y"),
        0x1D: _km("w", "W"),
        0x1E: _km("&", "1"),
        0x1F: _km("\u00e9", "2"),
        0x20: _km('"', "3"),
        0x21: _km("'", "4"),
        0x22: _km("(", "5"),
        0x23: _km("-", "6"),
        0x24: _km("\u00e8", "7"),
        0x25: _km("_", "8"),
        0x26: _km("\u00e7", "9"),
        0x27: _km("\u00e0", "0"),
        0x2D: _km(")", "\u00b0"),
        0x2E: _km("=", "+"),
        0x2F: _km("^", "\u00a8"),
        0x30: _km("$", "\u00a3"),
        0x31: _km("*", "\u00b5"),
        0x33: _km("m", "M"),
        0x34: _km("\u00f9", "%"),
        0x35: _km("\u00b2", "~"),
        0x36: _km(";", "."),
        0x37: _km(":", "/"),
        0x38: _km("!", "\u00a7"),
        0x2B: _km("\t"),
        0x28: _km("\n"),
        0x2C: _km(" "),
    }


LAYOUTS = {
    "qwerty": _build_qwerty_layout(),
    "azerty": _build_azerty_layout(),
}


def decode_keylog(data: bytes, layout: str, raw_tokens: bool) -> str:
    mapping = LAYOUTS[layout]
    if len(data) % 2:
        raise ValueError("Dump must contain an even number of bytes (key code + modifier).")

    decoded: list[str] = []
    codes = data[0::2]
    modifiers = data[1::2]

    for key_code, modifier in zip(codes, modifiers):
        if key_code in IGNORED_KEYCODES:
            continue

        shift_pressed = bool(modifier & SHIFT_MASK)

        if key_code == BACKSPACE_CODE:
            if raw_tokens:
                decoded.append("<BSPACE>")
            elif decoded:
                decoded.pop()
            continue
        if key_code == TAB_CODE:
            decoded.append("<TAB>" if raw_tokens else "\t")
            continue
        if key_code == ENTER_CODE:
            decoded.append("<ENTER>" if raw_tokens else "\n")
            continue

        mapped = mapping.get(key_code)
        if mapped:
            decoded.append(mapped.resolve(shift_pressed))
            continue

        token = SPECIAL_TOKENS.get(key_code)
        if token:
            decoded.append(token)

    return "".join(decoded)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Decode Rubber Ducky dumps with selectable keyboard layouts.")
    parser.add_argument("mode", choices=("display", "decode"), help="display = show raw tokens, decode = apply edits/backspaces")
    parser.add_argument("filename", help="binary dump to analyze")
    parser.add_argument(
        "--layout",
        "-l",
        choices=sorted(LAYOUTS),
        default="qwerty",
        help="Keyboard layout used by the attacker (default: qwerty)",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help="Write the decoded result to this file (optional).",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    data = Path(args.filename).read_bytes()
    raw_tokens = args.mode == "display"
    result = decode_keylog(data, layout=args.layout, raw_tokens=raw_tokens)
    if args.output:
        args.output.write_text(result)
    print(result, end="")


if __name__ == "__main__":
    main()
